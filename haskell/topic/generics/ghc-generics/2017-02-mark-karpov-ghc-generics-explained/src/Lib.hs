{-# LANGUAGE DefaultSignatures #-}
{-# LANGUAGE DeriveGeneric     #-}
{-# LANGUAGE FlexibleContexts  #-}
{-# LANGUAGE TypeOperators     #-}

module Lib where

import GHC.Generics
import GHC.Natural
import Prelude hiding (Functor, fmap)

someFunc :: IO ()
someFunc = putStrLn "someFunc"

{-
https://www.stackbuilders.com/tutorials/haskell/generics/

Generics are a way to use the same code to manipulate different data types.

Polymorphism, also supports that:
- parametric polymorphism : type variables enable function to work with any type(s)
- ad-hoc polymorphism : enables same operations abstracted over instances of type classes.

Generics provides and enables writing functions on types that describe shape and meta information
about a data type.  Generics also automatically generate 'to' and 'from' functions to handle the shape types.

The idea about generics

Generis utilies type classes and ad-hoc polymorphism.

data type that is an instance of the type class can be processed by functions that work
with a representation of data type, not the data type itself.

1. a type gets Generic instance automatically via DeriveGeneric

2. Generic(1) class instance.  When a type derive (Generic) it is an instance of Generic(1).

Note: see https://chrisdone.com/posts/data-typeable/ for the Data / Typeable approach

data V1 p                               : aata types withno constructors (e.g, Void)
data U1 p        = U1                   : constructors no args
data (f :+: g) p = L1 (f p)  | R1 (g p) : sums for types with two alternatives (more with nesting)
data (f :*: g) p =    (f p) :*:   (g p) : products

...

Generic (for kind *) and Generic1 (for kind * -> *) type classes

transform types to their reps and back

class Generic a where
  type Rep a :: * -> *
  from :: a -> Rep a p
  to   :: Rep a p -> x

class Generic1 f where
  type Rep1 f :: * -> *
  from1 :: f p -> Rep1 f p
  to1   :: Rep1 f p -> f p


import GHC.Generics
:t (undefined :: Rep ([]a) p)
  :: D1
       ('MetaData "[]" "GHC.Types" "ghc-prim" 'False)
       (C1 ('MetaCons "[]" 'PrefixI 'False) U1
        :+: C1
              ('MetaCons ":" ('InfixI 'LeftAssociative 9) 'False)
              (S1
                 ('MetaSel
                    'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                 (Rec0 a)
               :*: S1
                     ('MetaSel
                        'Nothing 'NoSourceUnpackedness 'NoSourceStrictness 'DecidedLazy)
                     (Rec0 [a])))
       p

Metadata wrappers : note the representation also has associated metadata.

newtype M1 i c f p = M1 { unM1 :: f p } -- ‘f p’ is what lives inside, U1 for example
--         ^ ^
--         | |
--         | +---- compiler-generated data type that allows us to get meta information
--         |
--  type-level tag, see below

i type-level tag can be:
- D : data type       metadata type D1 = M1 D
- C : constructor     metadata type C1 = M1 C
- S : record selector metadata type S1 = M1 S

ignore metadata easily via:

f (M1 x) = f x

or look for particular type of metadata via the i type-level tag

or leave unspecified to deal with all metadata

c : auto-generated by the compiler : encodes metadata on type level

c not put in value level because if it was there it would require providing it to generate a value.
Providing metadata for an existing data type is a job for the compiler.

wrappers are generated

D1 : entire rep : provides datatype-level info (name, module, is newtype?)

C1 : constructor : provides constructor info (name, fixity, is a record?).

S1 : constructor arg : provides selector name (even if not a record selector)

usage : give wrapped data to 'datatypeName' to get info

Example: counting the number of arguments given to a constructor value.
-}

{-
class NumArgs a where
  -- | Return number of constuctor fields for a value.
  numArgs :: a -> Natural

instance NumArgs (V1 p) where
  numArgs _ = 0

instance NumArgs (U1 p) where
  numArgs _ = 0

instance NumArgs (K1 i c p) where
  numArgs _ = 1

instance NumArgs (f p) => NumArgs (M1 i c f p) where
  numArgs (M1 x) = numArgs x

instance (NumArgs (a p), NumArgs (b p)) => NumArgs ((a :+: b) p) where
  numArgs (L1 x) = numArgs x
  numArgs (R1 x) = numArgs x

instance (NumArgs (a p), NumArgs (b p)) => NumArgs ((a :*: b) p) where
  numArgs (a :*: b) = numArgs a + numArgs b

defaultNumArgs :: (Generic a, NumArgs (Rep a)) => a -> Natural
defaultNumArgs = numArgs . from

    • Expecting one more argument to ‘Rep a’
      Expected a type, but ‘Rep a’ has kind ‘* -> *’
    • In the first argument of ‘NumArgs’, namely ‘(Rep a)’
      In the type signature:
        defaultNumArgs :: (Generic a, NumArgs (Rep a)) =>
                              a -> Natural

Does not compile
NumArgs has kind :: * -> Constraint
but it is given a Rep a of kind * -> *

typical solution : helper class that works with kind * -> * kind
(also removes the p parameters from signatures)
-}

class NumArgs1 f where
  numArgs1 :: f p -> Natural

defaultNumArgs :: (Generic a, NumArgs1 (Rep a)) => a -> Natural
defaultNumArgs = numArgs1 . from

instance NumArgs1 V1 where
  numArgs1 _ = 0

instance NumArgs1 U1 where
  numArgs1 _ = 0

instance NumArgs1 (K1 i c) where
  numArgs1 _ = 1

instance NumArgs1 f => NumArgs1 (M1 i c f) where
  numArgs1 (M1 x) = numArgs1 x

instance (NumArgs1 a, NumArgs1 b) => NumArgs1 (a :+: b) where
  numArgs1 (L1 x) = numArgs1 x
  numArgs1 (R1 x) = numArgs1 x

instance (NumArgs1 a, NumArgs1 b) => NumArgs1 (a :*: b) where
  numArgs1 (a :*: b) = numArgs1 a + numArgs1 b

{-
notice some types like Par0, Rec1 did not get their definitions.
OK because working with Generic above, not Generic1.
Omitting defs for some types that generic reps are built from is normal.
GHC.Generics docs:

- If no :+: instance given, function may still work for empty datatypes
or datatypes that have a single constructor,
but will fail on datatypes with more than one constructor.

- If no :*: instance given, function may still work for datatypes
where each constructor has just zero or one field, in particular for enumeration types.

- If no K1 instance  given, function may still work for enumeration types,
where no constructor has any fields.

- If no V1 instance  given, function may still work for any datatype that is not empty.

- If no U1 instance  given, function may still work for any datatype
where each constructor has at least one field.

- M1 instance is always required (but it can just ignore the meta-information).
-}

{-
Putting the magic into the type classes

For a generic impl to work without user's definition it needs a default definition.
A generic impl often involves a Generic constraint.
Would be ugly to add to every type class just to make deriving easier.

The default keyword (via DefaultSignatures) enables giving a different type signature
for default implementation of a type class:
-}

class NumArgs a where
  numArgs         ::                                  a -> Natural
  default numArgs :: (Generic a, NumArgs1 (Rep a)) => a -> Natural
  numArgs          = defaultNumArgs

----------------------------------------------------------------------------
-- Tests

instance NumArgs (Maybe a)

data Foo = Foo Int Int Int | Bar Bool
  deriving (Show, Generic)

instance NumArgs Foo
